import subprocess
from dataclasses import dataclass
from typing import Dict, List, Optional

from structures import State


BCP_INPUT = "bcp_input.txt"
BCP_OUTPUT = "bcp_output.txt"
MASTER_TRACE_FILE = "execution_trace.txt" 
FINAL_MODEL_FILE = "final_model.txt"
P3_COMMAND = ["python", "inference_engine.py"] # P3-Inference Engine runner command


@dataclass
class BCPResult:
    status: str                # 'SAT', 'UNSAT', 'CONFLICT', 'CONTINUE'
    dl: int                    # Decision level after BCP
    conflict_id: Optional[int] # Conflict clause ID if any
    exec_log: List[str]        # Execution log for traces
    var_states: Dict[int, str] # Current assignment state for each variable ('TRUE', 'FALSE', 'UNASSIGNED')

# Initialize Master Trace File (Clear previous data)
def initialize_master_trace():
    open(MASTER_TRACE_FILE, "w").close()

    # with open(MASTER_TRACE_FILE, "w") as f:
        # f.write("--- MASTER EXECUTION TRACE START ---\n")

# Append P3-Inference Engine logs to the master trace
def append_to_master_trace(exec_log: List[str]):
    with open(MASTER_TRACE_FILE, "a") as f:
        for line in exec_log:
            f.write(line + "\n")
        # f.write("--------------------------------------------------\n")

# DECIDE format comptible with sample log
def append_decision_to_master_trace(lit: int, dl: int):
    with open(MASTER_TRACE_FILE, "a") as f:
        f.write(f"[DL{dl}] DECIDE      L={lit}   |\n")

# Specify the new decision assignment and current level
def write_bcp_trigger(trigger_lit: int, dl: int):
    """
    The format of the trigger file:
    TRIGGER_LITERAL: 1
    DL: 1
    """
    with open(BCP_INPUT, "w") as f:
        f.write(f"TRIGGER_LITERAL: {trigger_lit}\n")
        f.write(f"DL: {dl}\n")

# Read BCP output file generated by Inference Engine
def read_bcp_output() -> BCPResult:
    status = None
    dl = 0
    conflict_id: Optional[int] = None
    exec_log: List[str] = []
    var_states: Dict[int, str] = {}

    section = None

    with open(BCP_OUTPUT, "r") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            
            # Identify the section of output that will be parsed
            if line.startswith("---"):
                if "STATUS" in line:
                    section = "STATUS"
                elif "BCP EXECUTION LOG" in line:
                    section = "LOG"
                elif "CURRENT VARIABLE STATE" in line:
                    section = "STATE"
                continue

            if section == "STATUS":
                if line.startswith("STATUS:"):
                    status = line.split(":")[1].strip()
                elif line.startswith("DL:"):
                    dl = int(line.split(":")[1].strip())
                elif line.startswith("CONFLICT_ID:"):
                    txt = line.split(":")[1].strip()
                    conflict_id = None if txt == "None" else int(txt)

            elif section == "LOG":
                exec_log.append(line)

            elif section == "STATE":
                left, right = line.split("|")
                var_id = int(left.strip())
                var_states[var_id] = right.strip()

    return BCPResult(status, dl, conflict_id, exec_log, var_states)

# Apply P3-Inference Engine output to Search Engine state
def apply_bcp_result_to_state(state: State, result: BCPResult):
    for var_id, val in result.var_states.items():
        if val == "UNASSIGNED":
            continue

        new_val = True if val == "TRUE" else False

        # Record new assignments to maintain the trail and decision level tracking
        if state.assignments[var_id] is None:
            state.assignments[var_id] = new_val
            state.levels[var_id] = result.dl
            state.trail.append((var_id, result.dl))
        else:
            # GPT BOYLE OLMASI GEREKTIGINI SAVUNUYO BURAYA BAKILCAK
            if state.assignments[var_id] != new_val:
                continue

            # ESKI HALI
            # Update state if already assigned
            # state.assignments[var_id] = new_val


def run_inference(state: State, current_dl: int) -> str:
    """
    Steps:
    1. Write trigger file
    2. Run Inference Engine (P3)
    3. Read output and record execution log
    4. Update internal State
    5. Analyze status to determine DPLL's next step
    """

    # Determine trigger literal from the most recent assignment in trail
    if state.trail:
        var_id, _ = state.trail[-1]
        val = state.assignments[var_id]
        lit = var_id if val else -var_id
    else:
        # DL 0: No decision made yet, initial unit clause check
        lit = 0

    dl = current_dl

    # Step 1
    write_bcp_trigger(lit, dl)

    # Step 2
    subprocess.run(P3_COMMAND, check=True)

    # Step 3
    result = read_bcp_output()
    state.last_status = result.status
    state.last_conflict_id = result.conflict_id
    state.last_dl = result.dl

    if result.exec_log:
        append_to_master_trace(result.exec_log)

    # Step 4
    apply_bcp_result_to_state(state, result)
 
    # Step 5
    status_raw = result.status.upper()
    if status_raw == "SAT":
        return "SAT"
    if status_raw in ("UNSAT", "CONFLICT"):
        return "CONFLICT" # Forces backtracking in search
    return "CONTINUE"

def write_final_model(state, is_sat: bool):
    with open(FINAL_MODEL_FILE, "w") as f:
        f.write(f"STATUS: {'SAT' if is_sat else 'UNSAT'}\n")
        f.write("\n--- FINAL VARIABLE STATE ---\n")
        if not is_sat:
            return

        for var_id in range(1, state.num_vars + 1):
            v = state.assignments[var_id]
            if v is None:
                txt = "UNASSIGNED"
            else:
                txt = "TRUE" if v else "FALSE"
            f.write(f"{var_id}    | {txt}\n")