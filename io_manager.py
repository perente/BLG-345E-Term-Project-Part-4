
from dataclasses import dataclass
from typing import Dict, List, Optional

import shutil
import os
from structures import State, Clause


BCP_INPUT = "bcp_input.txt"
BCP_OUTPUT = "bcp_output.txt"
MASTER_TRACE_FILE = "execution_trace.txt" 
FINAL_MODEL_FILE = "final_model.txt"



@dataclass
class BCPResult:
    status: str                # 'SAT', 'UNSAT', 'CONFLICT', 'CONTINUE'
    dl: int                    # Decision level after BCP
    conflict_id: Optional[int] # Conflict clause ID if any
    exec_log: List[str]        # Execution log for traces
    var_states: Dict[int, str] # Current assignment state for each variable ('TRUE', 'FALSE', 'UNASSIGNED')


def setup_test_case(test_id: int):
    """
    Copies test files to the root directory for the given test_id.
    """
    test_dir = "test"
    test_id_str = f"{test_id:02d}"
    
    # Define source paths
    src_initial = os.path.join(test_dir, f"initial_state_test_{test_id_str}.txt")
    src_bcp_out = os.path.join(test_dir, f"bcp_output_{test_id_str}.txt")
    src_bcp_in = os.path.join(test_dir, f"bcp_input_{test_id_str}.txt")
    
    # Define dest paths
    dst_initial = "initial_state.txt"
    dst_bcp_out = BCP_OUTPUT
    dst_bcp_in = BCP_INPUT
    
    # Copy files
    if os.path.exists(src_initial):
        shutil.copy(src_initial, dst_initial)
        print(f"Copied {src_initial} to {dst_initial}")
    else:
        print(f"Warning: {src_initial} not found.")

    if os.path.exists(src_bcp_out):
        shutil.copy(src_bcp_out, dst_bcp_out)
        print(f"Copied {src_bcp_out} to {dst_bcp_out}")
    else:
        print(f"Warning: {src_bcp_out} not found.")

def load_test_state(path: str) -> State:
    """
    Parses the custom initial_state_test file format.
    """
    num_vars = 0
    clauses = []
    assignments = {}
    
    section = None
    
    with open(path, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("---"):
                if "VARIABLE ASSIGNMENTS" in line:
                    section = "VARS"
                elif "CLAUSE LIST" in line:
                    section = "CLAUSES"
                elif "HEADER" in line:
                    section = "HEADER"
                else:
                    section = None
                continue
            
            if section == "HEADER":
                if line.startswith("V:"):
                    num_vars = int(line.split(":")[1].strip())
            
            elif section == "VARS":
                # Format: 1    | UNASSIGNED  or  2    | TRUE
                parts = line.split("|")
                if len(parts) >= 2:
                    try:
                        var_id = int(parts[0].strip())
                        val_str = parts[1].strip()
                        if val_str == "TRUE":
                            assignments[var_id] = True
                        elif val_str == "FALSE":
                            assignments[var_id] = False
                    except ValueError:
                        pass

            elif section == "CLAUSES":
                # Format: C1    | [-7, -2, -10]     | [0, 1]
                parts = line.split("|")
                if len(parts) >= 2:
                    # Parse literals: [-7, -2, -10]
                    lits_str = parts[1].strip()
                    lits_str = lits_str.strip("[]")
                    if lits_str:
                        lits = [int(x.strip()) for x in lits_str.split(",")]
                        cid_str = parts[0].strip()[1:] # Remove 'C'
                        cid = int(cid_str)
                        clauses.append(Clause(cid, lits))
    
    state = State(clauses, num_vars)
    
    # Apply loaded assignments
    for var_id, val in assignments.items():
        state.assign(var_id, val, 0)
        
    return state

# Initialize Master Trace File
def initialize_master_trace():
    open(MASTER_TRACE_FILE, "w").close()

    # with open(MASTER_TRACE_FILE, "w") as f:
        # f.write("--- MASTER EXECUTION TRACE START ---\n")

# Append P3-Inference Engine logs to the master trace
def append_to_master_trace(exec_log: List[str]):
    with open(MASTER_TRACE_FILE, "a") as f:
        for line in exec_log:
            f.write(line + "\n")
        # f.write("--------------------------------------------------\n")

# DECIDE format comptible with sample log
def append_decision_to_master_trace(lit: int, dl: int):
    with open(MASTER_TRACE_FILE, "a") as f:
        f.write(f"[DL{dl}] DECIDE      L={lit}   |\n")

# Specify the new decision assignment and current level
def write_bcp_trigger(trigger_lit: int, dl: int):
    """
    The format of the trigger file:
    TRIGGER_LITERAL: 1
    DL: 1
    """
    with open(BCP_INPUT, "w") as f:
        f.write(f"TRIGGER_LITERAL: {trigger_lit}\n")
        f.write(f"DL: {dl}\n")

# Read BCP output file generated by Inference Engine
def read_bcp_output() -> BCPResult:
    status = None
    dl = 0
    conflict_id: Optional[int] = None
    exec_log: List[str] = []
    var_states: Dict[int, str] = {}

    section = None

    with open(BCP_OUTPUT, "r") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            
            # Identify the section of output that will be parsed
            if line.startswith("---"):
                if "STATUS" in line:
                    section = "STATUS"
                elif "BCP EXECUTION LOG" in line:
                    section = "LOG"
                elif "CURRENT VARIABLE STATE" in line:
                    section = "STATE"
                continue

            if section == "STATUS":
                if line.startswith("STATUS:"):
                    status = line.split(":")[1].strip()
                elif line.startswith("DL:"):
                    dl = int(line.split(":")[1].strip())
                elif line.startswith("CONFLICT_ID:"):
                    txt = line.split(":")[1].strip()
                    conflict_id = None if txt == "None" else int(txt)

            elif section == "LOG":
                exec_log.append(line)

            elif section == "STATE":
                left, right = line.split("|")
                var_id = int(left.strip())
                var_states[var_id] = right.strip()

    return BCPResult(status, dl, conflict_id, exec_log, var_states)

# Apply P3-Inference Engine output to Search Engine state
def apply_bcp_result_to_state(state: State, result: BCPResult):
    for var_id, val in result.var_states.items():
        if val == "UNASSIGNED":
            continue

        new_val = True if val == "TRUE" else False

        # Record new assignments to maintain the trail and decision level tracking
        if state.assignments[var_id] is None:
            state.assignments[var_id] = new_val
            state.levels[var_id] = result.dl
            state.trail.append((var_id, result.dl))
        else:
            if state.assignments[var_id] != new_val:
                continue


def run_inference(state: State, current_dl: int) -> str:
    """
    Steps:
    1. Write trigger file
    2. Run Inference Engine (P3)
    3. Read output and record execution log
    4. Update internal State
    5. Analyze status to determine DPLL's next step
    """

    # Determine trigger literal from the most recent assignment in trail
    if state.trail:
        var_id, _ = state.trail[-1]
        val = state.assignments[var_id]
        lit = var_id if val else -var_id
    else:
        # DL 0: No decision made yet, initial unit clause check
        lit = 0

    dl = current_dl

    # Step 1
    write_bcp_trigger(lit, dl)
    pass

    # Step 3
    result = read_bcp_output()
    state.last_status = result.status
    state.last_conflict_id = result.conflict_id
    state.last_dl = result.dl

    if result.exec_log:
        append_to_master_trace(result.exec_log)

    # Step 4
    apply_bcp_result_to_state(state, result)
 
    # Step 5
    status_raw = result.status.upper()
    if status_raw == "SAT":
        return "SAT"
    if status_raw in ("UNSAT", "CONFLICT"):
        return "CONFLICT" # Forces backtracking in search
    return "CONTINUE"

def write_final_model(state, is_sat: bool):
    with open(FINAL_MODEL_FILE, "w") as f:
        f.write(f"STATUS: {'SAT' if is_sat else 'UNSAT'}\n")
        f.write("\n--- FINAL VARIABLE STATE ---\n")
        if not is_sat:
            return

        for var_id in range(1, state.num_vars + 1):
            v = state.assignments[var_id]
            if v is None:
                txt = "UNASSIGNED"
            else:
                txt = "TRUE" if v else "FALSE"
            f.write(f"{var_id}    | {txt}\n")